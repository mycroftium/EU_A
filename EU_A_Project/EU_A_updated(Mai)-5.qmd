---
title: "EU_A_new"
format: html
editor: visual
---

## Group assignment

The aim of this group assignment is to tidy both files so that they adhere to all four data tidying principles.

1.  Each type of case must have its own tibble

2.  Each observation must have its own row

3.  Each variable must have its own column

4.  Each value must have its own cell.

Mai's RQ:

*RQ1: To what extent is people's attitude toward the EU and their political cynicism developed throughout the EU election?*

*RQ2: To what extent is people's attitude toward the EU and their political cynicism related to the media content they were exposed to?*

In the All_Waves document, variables needed:

| ***Panel Survey*** |   |   |   |   |
|---------------|---------------|---------------|---------------|---------------|
| **Variable** | **Wave 1** | **Wave 2** | **Wave 3** | **Wave 4** |
| Political cynicism | Q10 | Q7 | Q11 | Q13 |
| EU attitudes | Q26, Q27 | Q22, Q23 | Q28, Q29 | Q31, Q32 |
| Self reported media exposure (TV) | Q49 | Q44 | Q43 | Q47 |
| Self reported media exposure (newspapers) | Q50 | Q45 | Q44 | Q48 |
| Self reported media exposure (Internet) | Q51 | Q46 | Q45 | Q49 |

Notes: In wave 1, 7 = pro EU for all nine items of Q26. In Q27, 7 = pro-EU for item 1, 2, 3, 4, 9 ;while 7 = against EU for item 5, 6, 7, 8.

| *Content analysis* |   |
|------------------------------------|------------------------------------|
| **Variable** | **Label** |
| How does the specific media evaluate the EU | V11 |
| How does the specific media evaluate the European Parliament | V12 |
| If the specific media mention a certain aspect related to the state of democracy in the EU and how do they evaluate it. | V13 |

In the content analysis documents, variables needed:

`V11`: How does the specific media evaluate the EU

`V12`: How does the specific media evaluate the European Parliament

`V13`: If the specific media mention a certain aspect related to the state of democracy in the EU and how do they evaluate it.

Bará's RQs:

1.  How does the readership of Dutch media outlets differ in their attitudes regarding migration?

2.  How do Dutch media outlets cover migration?

Variables Barbora:

| ***Panel Survey***          |            |            |            |            |
|---------------|---------------|---------------|---------------|---------------|
| **Variable**                | **Wave 1** | **Wave 2** | **Wave 3** | **Wave 4** |
| Most important issue        | Q01        | Q01        | Q01        | Q01        |
| Intergroup comfort: Muslims | Q54        | Q48        |            |            |
| Intergroup comfort: Poles   | Q56        | Q49        |            |            |
| Ethnic minority             | Q68        |            |            |            |
| Anti-immigrant attitudes    | Q42        | Q39        |            |            |
| Immigrant follow up         | Q43        | Q40        |            |            |

| *Content analysis* |            |
|--------------------|------------|
| **Variable**       | **Label**  |
| Outlet             | V4         |
| Topic              | V6_cleaned |
| Day                | V3a        |
| Month              | V3b        |
| Year               | V3c        |
| Emotion            | NL1 a-f    |
| Mention Muslims    | NL2        |
| Evaluation Muslims | NL3        |
| Mention Poles      | NL4        |
| Evaluation Poles   | NL5        |

Sará's RQs:

How does the intention to vote differ between EU and local elections, and what is the relationship between the difference and national identity, attitude towards globalisation and anti-immigrant attitudes 6 months prior to the EU elections in regards to the media outlet voters are consuming content from?

Sará's RQs:

| ***Panel survey***             |        |        |        |        |
|--------------------------------|--------|--------|--------|--------|
| **Variable**                   | Wave 1 | Wave 2 | Wave 3 | Wave 4 |
| National identity              | Q05    |        |        |        |
| Attitudes globalisation        | Q32    |        |        |        |
| Vote intention EU              | Q34    |        |        |        |
| Vote intention local elections | Q39    |        |        |        |
| Anti-immigrant attitudes       | Q42    |        |        |        |
| Highest completed education    | Q61    |        |        |        |
| Income                         | Q65    |        |        |        |
| Employment status              | Q67    |        |        |        |
| Age                            |        |        |        |        |
| Gender                         |        |        |        |        |

| *Content analysis* |           |
|--------------------|-----------|
| **Variable**       | **Label** |
| Outlet             | V4        |

## 1. Rename variables

In the raw file, most of the variable names are structured in such a way that it has different question number in different waves.

For instance: `Political cynicism`: Q10 (wave 1), Q07 (wave 2), Q11 (wave 3), Q13 (wave 4).

Therefore, it is easier for further tidying if we capture all four questions measuring a certain variable in different waves and rename them into a consistent name e.g., `w1_polcyn_1`, `w2_polcyn_2`, etc.

This data tidying process adheres data tidying principle 1: Each type of case must have its own tibble.

First, we import relevant R library and dataset.

```{r}
library(tidyverse)
```

```{r}
# Import two data sets. The path is relative and should work as long as the 'EU2014' file is stored in the same location as R is running
EU_2014 <- read.csv('EU2014/All waves GENERAL.csv') 
```

Now rename variables:

```{r}
# giving columns informative names, translating dutch names
EU_2014_renamed <- EU_2014 |>
rename(
  weight_w1 = GEWICHTA1_w1,
  weight_w2 = GEWICHTA1_w2,
  weight_w3 = GEWICHTA1_w3,
  weight_w4 = GEWICHTA1_w4,
  gender = GSL,
  age = LFT,
  education = OPLA,
  region = NIELSENCBS, 
  family_size = GEZINSGROOTTE,
  pol2012 = POL2012,
  w1_date = w1_DATUM,
  w1_time = w1_TIJD,
  w2_date = w2_DATUM,
  w2_time = w2_TIJD,
  w3_date = w3_DATUM, 
  w3_time = w3_TIJD,
  w4_date = w4_DATUM,
  w4_time = w4_TIJD,
) 
colnames(EU_2014_renamed) <- tolower(colnames(EU_2014_renamed))             # tolower() takes column names and turns them into lower case

# this function changes all column names to lowercase 
# (more consistent and easy to use)
```

## 2. Select the variables that will be used in the analysis (Principle 1)

Before splitting the tibble "EU_2014_renamed", we believe that `intnr` and `respnr` could both independently uniquely identify each input, thus both could act as the primary key. Out of convenience, we use `respnr` as the primary key.

```{r}
EU_2014_renamed |> 
  count(intnr) |>                        
  filter(n >1)                           # filters rows with repeated values for intnr

EU_2014_renamed |> 
  count(respnr) |> 
  filter(n>1)
```

We are extracting and creating a new tibble out of the tibble "EU_2014_renamed" (the table containing all survey data), namely "EU_needed".

We also extract variables that will be further processed in our analysis out of the "content_analysis" tibble, namely "ca_needed"



```{r}
# Now, we split the "all_waves" df into two tibbles, one contains variables that we need for further analysis and the other that contains variables that will not be used

EU_2014_cleaned <- EU_2014_renamed |> 
  select(
        intnr, respnr, sample, waves, 
        weight_w1, weight_w2, weight_w3, weight_w4, 
        gender, age, education, region, family_size, pol2012,
        w1_date, w1_time, w2_date, w2_time, w3_date,
        w3_time, w4_date, w4_time, 
        matches("^w1_q1$"), matches("^w2_q1$"), # Barbora's variables
        matches("^w3_q1$"), matches("^w4_q1$"), 
        starts_with("w1_q54"), starts_with("w1_q56"),
        starts_with("w1_q68"), starts_with("w1_q42"),
        starts_with("w1_q43"), starts_with("w2_q48"),
        starts_with("w2_q49"), starts_with("w2_q40"), 
        starts_with("w1_q10"), matches("w2_q7$"), # Mai's variables
        starts_with("w3_q11"), starts_with("w4_q13"),
        starts_with("w1_q26"), starts_with("w1_q27"),
        starts_with("w2_q22"), starts_with("w2_q23"),
        starts_with("w3_q28"), starts_with("w3_q29"),
        starts_with("w4_q31"), starts_with("w4_q32"),
        starts_with("w1_q49"), starts_with("w2_q44"),
        starts_with("w3_q43"), starts_with("w4_q47"),
        starts_with("w1_q50"), starts_with("w2_q45"),
        starts_with("w3_q44"), starts_with("w1_q51"),
        starts_with("w2_q46"), starts_with("w3_q45"),
        starts_with("w4_q49"),
        matches("w1_q5_"), starts_with("w1_q32"), # Sara's variables
        starts_with("w1_q34"), starts_with("w1_q39"),
        starts_with("w1_q42"), starts_with("w1_q61"), 
        starts_with("w1_q65"), starts_with("w1_q67")
  )
```

After splitting, we have two working tibbles:

1\) `EU_2014_cleaned` this contains all the variables that will be included in further analysis, where `intnr` is the primary key


3\) `ca_needed` this tibble contains all the variables that will be included in the further analysis that is related to the content analysis. `v2` is the primary key in this tibble.

## 3. Giving variables more informative names

Since the variable names in the document is in the format of "w1_q1_1" where the question number differs across different wave. We would like to standardise variable names.

```{r}
# creating a vector capturing column names
EU_2014_cleaned <- EU_2014_cleaned |> 
    rename_with(function(x) gsub("w1_q5_", "w1_national_identity_", x, fixed = TRUE)) |>         # gsub takes the pattern in the first argument and replaces it with that in the next 
    rename_with(function(x) gsub("w1_q32", "w1_attitude_global", x, fixed = TRUE)) |>            # argument
    rename_with(function(x) gsub("w1_q34", "w1_vote_intention_eu", x, fixed = TRUE)) |>          # function(x) tells rename_with() that how to deal with the object passed will be
    rename_with(function(x) gsub("w1_q39", "w1_vote_intention_local", x, fixed = TRUE)) |>       # specified in a function that's coming (x is a placeholder for EU_2014 cleaned
    rename_with(function(x) gsub("w1_q42", "w1_anti_immigrant", x, fixed = TRUE)) |>             #
    rename_with(function(x) gsub("w1_q10", "w1_political_cynicism", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q7", "w2_political_cynicism", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w3_q11", "w3_political_cynicism", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w4_q13", "w4_political_cynicism", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w1_q26", "w1_eu_attitude", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q22", "w2_eu_attitude", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w3_q28", "w3_eu_attitude", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w4_q31", "w4_eu_attitude", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w1_q27", "w1_eu_attitude2", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q23", "w2_eu_attitude2", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w3_q29", "w3_eu_attitude2", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w4_q32", "w4_eu_attitude2", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w1_q49", "w1_media_exposure_tv", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q44", "w2_media_exposure_tv", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w3_q43", "w3_media_exposure_tv", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w4_q47", "w4_media_exposure_tv", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w1_q50", "w1_media_exposure_newspaper", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q45", "w2_media_exposure_newspaper", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w3_q44", "w3_media_exposure_newspaper", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w4_q48", "w4_media_exposure_newspaper", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w1_q51", "w1_media_exposure_internet", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q46", "w2_media_exposure_internet", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w3_q45", "w3_media_exposure_internet", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w4_q49", "w4_media_exposure_internet", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w1_q1", "w1_most_important_issue", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q1", "w2_most_important_issue", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w3_q1", "w3_most_important_issue", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w4_q1", "w4_most_important_issue", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w1_q54", "w1_comfort_muslims", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q48", "w2_comfort_muslims", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w1_q56", "w1_comfort_poles", x, fixed = TRUE)) |>
    rename_with(function(x) gsub("w2_q49", "w2_comfort_poles", x, fixed = TRUE)) |>
    rename(w1_ethnic_minority = w1_q68) |>
    rename(w1_ethnic_minority_specification = w1_q68_yes) |>
    rename_with(function(x) gsub("w2_q39", "w2_anti_immigrant_attitudes", x, fixed = TRUE)) |>
    rename(w1_immigrant_followup = w1_q43) |>
    rename(w2_immigrant_followup = w2_q40) |>
    rename(w1_highest_completed_education = w1_q61) |>
    rename(w1_income = w1_q65) |>    
    rename(w1_employment_status = w1_q67)


## 4. Separate numbers with labels (Principle 4)

Principle 4 of the tidy tidying principle is: Each value must have its own cell.

We should get rid of the textual explanation within each input (e.g., 1 helemaal mee oneens) by creating a new column capturing the label information.

```{r}

# creating a vector capturing column names that have cells which include a number and its label
# this vector will be used to select these columns from the dataset within separate_wider

columns_for_separation <- EU_2014_cleaned |>
  select_if(function(col) any(grep("1 hele|1 geen", col))) |> # selects only columns with cells
  colnames()   # keeps only the names of the columns          # incl pattern in grep()

```

```{r}
# separating scores and labels into two separate columns

EU_2014_cleaned <- EU_2014_cleaned |>
  separate_wider_delim(
    cols = all_of(columns_for_separation), # takes columns the names of which are in the object
    delim = stringr::regex(" (?=helemaal*)|(?=heel*)|(?=in redelijke mate)|(?=een beetje)|(?=zeer goed)|(?=geen)|(?=ongeveer)|(?=bijna alleen maar)"), # specifies the delim pattern
    names = c("score","label"),
    names_sep = "_",     # new columns given the old name "_" and a number
    too_few = "align_start", 
    cols_remove = TRUE
) 


# We are parsing variables media_exposure_tv, media_exposure_newspaper, and media_exposure_internet.
# since its current value also includes the unit (dagen per week)
media_exposure = c(
          "w1_media_exposure_tv", "w2_media_exposure_tv", 
          "w3_media_exposure_tv", "w4_media_exposure_tv",
          "w1_media_exposure_newspaper", "w2_media_exposure_newspaper", 
          "w3_media_exposure_newspaper", "w4_media_exposure_newspaper", 
          "w1_media_exposure_internet", "w2_media_exposure_internet",  
          "w3_media_exposure_internet", "w4_media_exposure_internet"
)
          
          
EU_2014_cleaned <- EU_2014_cleaned |> 
  mutate(across(starts_with(media_exposure), parse_number))


# some problems with w1_national_identity? 
# check w2_q23 as well
```

## 5. Pivot_longer all the waves information (Principle 2)

In the new tibble "waves", we see many variables that are measured with several waves. This violates the data tidying principle 2, namely *each observation must have its own row*. To address this, we use function `pivot_longer()`. **(waves)**

```{r}
# pivot_longer() tackling waves. The code should create a new column: wave

EU_2014_cleaned <- EU_2014_cleaned |>
  pivot_longer(
    cols = c(starts_with("w1_"), starts_with("w2_"), starts_with("w3_"), starts_with("w4_")),
    names_to = c("wave", ".value"),
    names_pattern = "w(.)_(.*)"
  )
#view(EU_2014_cleaned)
```


## 6. Determine the primary keys and foreign keys of the table

After pivot_longer(), we have the data in a long format, where many variables are repeated. This is violating the first principle of data tidying, namely each type of case must have its own tibble.

Therefore, we need to split the full data set into separate tibbles based on different type of cases.

We believe that the tibble "EU_2014_cleaned" could be split into two tibbles based on various types of cases:

1.  demographic
2.  waves

Demographic includes variable:

`intnr` \*, `respnr` , `sample`, `waves`, `weight_1`, `weight_2`, `weight_3`, `weight_4`, `gender`, `age`, `education`, `region`, `family_size`, `pol2012`

where `intnr` will be the primary key.

`intnr` is the foreign key in tibble `waves`

The second tibble `waves` includes:

`intnr`, `wave`, `date`, `time`, `most_important_issue`, `comfort_muslims_score`, `comfort_muslims_label`, `comfort_poles_score`, `comfort_poles_label` (...)

There will be a total of 116 variables in the `waves` tibble

```{r}
# we create the "demographic" tibble by selecting corresponding variables
demographic <- EU_2014_cleaned |> 
  select(
    intnr, respnr, sample, waves, weight_w1, weight_w2, weight_w3, 
    weight_w4, gender, age, education, region, family_size, pol2012
  ) |> 
  distinct()

# now we test the primary key in tibble "demographic"
demographic |> 
  count(intnr) |> 
  filter(n>1)


# We then create the "waves" tibble by selecting corresponding variables
waves <- EU_2014_cleaned |> 
  select(
    intnr, wave, date, time, most_important_issue:political_cynicism_4_score
  ) |> 
  distinct()


# we now test the primary key in tibble "waves"
waves |> 
  count(intnr, wave) |> 
  filter(n>1)
```

Then we verify that those variables belong to the same type of case:

```{r}
# first we check whether all the variables in the "demographic" tibble belong to the same type of case
demographic |> 
  group_by(intnr) |> 
  summarise(n_distinct = n_distinct(respnr, sample, gender, age, education, region, family_size, pol2012, weight_w1, weight_w2, weight_w3, weight_w4 )) |> 
  count(n_distinct)

# Now we check whether all the variables in the "waves" tibble belong to the same type of case
# we first create a list of all the column names that appears in the "waves" tibble
# we see that there are 35 columns selected, so as long as the n_distinct in the next step is 35
# it means that all the variables in the tibble belong to the same type of case
col_names_wave <- waves |> 
  select(date, time, most_important_issue:political_cynicism_4_score) |> 
  colnames()


waves |> 
  group_by(intnr, wave) |> 
  summarise(n_distinct = n_distinct(col_names_wave), .groups = "drop") |> 
  count(n_distinct)


```

We believe that in tibble `demographic`, `intnr` act as the foreign key in tibble `waves`

We believe that in tibble `waves` , `intnr` act as the foreign key in tibble `demographic`

```{r}
# we test the foreign key by joining
waves |> 
  left_join(demographic, by = "intnr")

# we again test the foreig key by joining the two tibbles
demographic |> 
  left_join(waves, by = "intnr")

```

# Content analysis

```{r}
content_analysis <- read.csv('EU2014/Dataset MCA EPE 2014 NL FINAL.csv')
```

```{r}
colnames(content_analysis) <- tolower(colnames(content_analysis)) 
```

```{r}
# We then split the content analysis df into two tibbles: the variables that we need and the one that will not be cleaned

ca <- content_analysis |> 
  select(
    v2, # primary key
    v3a:v3c,
    v4,
    v6_cleaned,
    nl1a:nl1f,
    nl2_1_1:nl2_4_3,
    nl3,
    nl4_1_1:nl4_4_3,
    nl5
  )
```

### Cleaning dates and times

```{r}
# replacing year numbers 
  
ca |> 
count(v3c)

ca$v3c <- replace(ca$v3c, ca$v3c == 14, values = 2014)
ca$v3c <- replace(ca$v3c, ca$v3c == 13, values = 2013)

#view(ca)
```

```{r}
# using lubridate to set dates in date format

ca <- ca |> 
  mutate(date = make_date(v3c, v3b, v3a),.keep = "unused", .before = v4)

```

### Renaming variables

v3a:v3c,

```{r}

#renaming variables

ca <- ca |>
  rename(
    outlet = v4,
    topic = v6_cleaned,
    fear = nl1a,
    anger = nl1b,
    disgust = nl1c,
    hope = nl1d,
    frustration = nl1e,
    surprise = nl1f,
    mention_muslim_general_netherlands = nl2_1_1,
    mention_muslim_general_elweshere = nl2_1_2,
    mention_muslim_general_home = nl2_1_3,
    mention_muslim_moroccans_netherlands = nl2_2_1,
    mention_muslim_moroccans_elsewhere = nl2_2_2,
    mention_muslim_moroccans_home = nl2_2_3,
    mention_muslim_turkish_netherlands = nl2_3_1,
    mention_muslim_turkish_elsewhere = nl2_3_2,
    mention_muslim_turkish_home = nl2_3_3,
    mention_muslim_other_netherlands = nl2_4_1,
    mention_muslim_other_elsewhere = nl2_4_2,
    mention_muslim_other_home = nl2_4_3,
    evaluation_muslims = nl3,
    mention_east_poles_netherlands = nl4_1_1,
    mention_east_poles_elweshere = nl4_1_2,
    mention_east_poles_home = nl4_1_3,
    mention_east_eu_netherlands = nl4_2_1,
    mention_east_eu_elweshere = nl4_2_2,
    mention_east_eu_home = nl4_2_3,
    mention_east_general_netherlands = nl4_3_1,
    mention_east_general_elweshere = nl4_3_2,
    mention_east_general_home = nl4_3_3,
    mention_east_noneu_netherlands = nl4_4_1,
    mention_east_noneu_elweshere = nl4_4_2,
    mention_east_noneu_home = nl4_4_3,
    evaluation_eastern_europeans = nl5
    ) 
```

### Filtering rows needed

```{r}
# filtering rows needed for the analysis (Dutch media outlets)
ca |> 
  count(outlet)

ca <- ca |>
  filter(
    (outlet == "NRC Handelsblad") |
    (outlet == "de Volkskrant") |
    (outlet == "de Telegraaf") |
    (outlet == "NOS Journaal") |
    (outlet == "RTL Nieuws") |
    (outlet == "nu.nl")
  )

ca |>
  distinct(outlet)
```

### 

```{r}
# replacing blank cells with NA
ca <- ca |>
mutate(across(where(is.character), ~na_if(.x, ""))) |> 
  mutate(across(where(is.character), ~na_if(.x, " ")))

```
we test for possible primary key combinations for content_analysis

```{r}

content_analysis |>
  count(v2, v1, v3a, v4, np2, np5, v6_cleaned) |>
  filter(n>1)
```

```{r}
# Now we identify the primary key for tibble ca:

```{r}
# Now we identify the primary key for tibble ca_needed:

ca |>
  count(identifier, outlet, topic, fear, anger, disgust, hope) |>
  filter(n>1)
```

